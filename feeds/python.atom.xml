<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
 <title type="text">logc io: Posts tagged 'python'</title>
 <link rel="self" href="http://logc.github.io/feeds/python.atom.xml" />
 <link href="http://logc.github.io/tags/python.html" />
 <id>urn:http-logc-github-io:-tags-python-html</id>
 <updated>2014-04-01T15:22:00Z</updated>
 <entry>
  <title type="text">Python egg tagged with Git commit hash</title>
  <link rel="alternate" href="http://logc.github.io/blog/2014/04/01/python-egg-tagged-with-git-commit-hash?utm_source=python&amp;utm_medium=Atom" />
  <id>urn:http-logc-github-io:-blog-2014-04-01-python-egg-tagged-with-git-commit-hash</id>
  <published>2014-04-01T15:22:00Z</published>
  <updated>2014-04-01T15:22:00Z</updated>
  <author>
   <name>logc</name></author>
  <content type="html">
&lt;h2 id="svn"&gt;SVN&lt;/h2&gt;

&lt;p&gt;Python&amp;rsquo;s setuptools provide a simple mechanism to tag your built distributions with the SVN revision they belong to, by creating a &lt;code&gt;setup.cfg&lt;/code&gt; file along the normal &lt;code&gt;setup.py&lt;/code&gt;, and there write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[egg_info]
# Add svn revision to the file name
tag_svn_revision = 1&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="git"&gt;Git&lt;/h2&gt;

&lt;p&gt;How to do the same for Git? Or in general, with other information? (Date tagging is also supported by default).&lt;/p&gt;

&lt;p&gt;Answer: modify directly the &lt;code&gt;options&lt;/code&gt; dictionary in the call to &lt;code&gt;setup&lt;/code&gt;, in &lt;code&gt;setup.py&lt;/code&gt;. There, you can put anything you can compute with Python or system calls. E.g. for git:&lt;/p&gt;

&lt;div class="brush: python"&gt;
 &lt;pre&gt;&lt;code&gt;import shlex
from subprocess import check_output

GIT_HEAD_REV = check_output(shlex.split('git rev-parse --short HEAD')).strip()


setup(
    # ... other keys like project name, version, etc ...
    options = dict(egg_info = dict(tag_build = "dev_" + GIT_HEAD_REV)),
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With that setup, distributions (&lt;code&gt;sdist&lt;/code&gt; or &lt;code&gt;bdist&lt;/code&gt;) would be tagged with the string &amp;ldquo;dev&amp;rdquo; and the git hash of the latest commit:&lt;/p&gt;

&lt;div class="brush: console"&gt;
 &lt;pre&gt;&lt;code&gt;$ bin/python setup.py sdist bdist_egg
$ ls dist
pyhello-0.1dev-92ffa06.tar.gz    pyhello-0.1dev_92ffa06-py2.7.egg&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Whenever you want to build a stable release (without any &amp;ldquo;dev&amp;rdquo; tags), just set the key to empty in your &lt;code&gt;setup.cfg&lt;/code&gt;, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[egg_info]
tag_build =&lt;/code&gt;&lt;/pre&gt;</content></entry>
 <entry>
  <title type="text">Instalar Python 2.7 y NumPy sobre RedHat 6</title>
  <link rel="alternate" href="http://logc.github.io/blog/2013/12/04/instalar-python-2-7-y-numpy-sobre-redhat-6?utm_source=python&amp;utm_medium=Atom" />
  <id>urn:http-logc-github-io:-blog-2013-12-04-instalar-python-2-7-y-numpy-sobre-redhat-6</id>
  <published>2013-12-04T11:44:57Z</published>
  <updated>2013-12-04T11:44:57Z</updated>
  <author>
   <name>logc</name></author>
  <content type="html">
&lt;p&gt;RedHat y centOS tienen la fastidiosa dependencia de su gestor de paquetes, yum, con la versión 2.6 de Python desde tiempos inmemoriales. Lo que en tecnología son unos seis o siete años.&lt;/p&gt;

&lt;p&gt;Instalar Python 2.7 no es posible con los repositorios instalados por defecto, y si tienes la mala idea de instalar un repositorio donde sí esté y meterlo como paquete que supedita al python por defecto, te acabas de cargar yum (y la posibilidad más sencilla de deshacer tus cambios).&lt;/p&gt;

&lt;p&gt;La mejor manera, pese a lo que pueda parecer, es &lt;strong&gt;instalar desde fuentes&lt;/strong&gt;, haciendo lo que se conoce como &amp;ldquo;altinstall&amp;rdquo; (instalación alternativa). Esto crea ejecutables llamados &lt;code&gt;python2.7&lt;/code&gt; bajo &lt;code&gt;/usr/local/bin&lt;/code&gt;, que &lt;strong&gt;no sobreescriben&lt;/strong&gt; el comando &lt;code&gt;python&lt;/code&gt; normal del sistema; éste sigue apuntando a un ejecutable bajo &lt;code&gt;/usr/bin&lt;/code&gt;.&lt;/p&gt;

&lt;div class="brush: console"&gt;
 &lt;pre&gt;&lt;code&gt;$ wget http://www.python.org/ftp/python/2.7.6/Python-2.7.6.tgz
$ tar xvfz Python-2.7.6.tgz
$ cd Python-2.7.6
$ ./configure
$ make
$ sudo make altinstall&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Además de esto, es recomendable instalar &lt;strong&gt;un &lt;code&gt;easy_install&lt;/code&gt; alternativo también&lt;/strong&gt;, ya que, si no, todas las librerías de python se instalarán para la 2.6 y no para la 2.7.&lt;/p&gt;

&lt;div class="brush: console"&gt;
 &lt;pre&gt;&lt;code&gt;$ wget http://pypi.python.org/packages/2.7/s/setuptools/setuptools-0.6c11-py2.7.egg
$ sudo -i
# export PATH=$PATH:/usr/local/bin
# sh setuptools-0.6c11-py2.7.egg
# exit
$ sudo rm /usr/local/bin/easy_install ## remove the symlink that shadows the system easy_install
$ # You may now try the easy_install for 2.7 with e.g.:
$ sudo /usr/local/bin/easy_install-2.7 numpy&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Este post es una combinación de &lt;a href="http://stackoverflow.com/questions/4149361/on-linux-suse-or-redhat-how-do-i-load-python-2-7"&gt;dos respuestas en Stack Overflow&lt;/a&gt;, y mi propia experiencia con este mismo problema.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Unicode encodings</title>
  <link rel="alternate" href="http://logc.github.io/blog/2013/12/03/unicode-encodings?utm_source=python&amp;utm_medium=Atom" />
  <id>urn:http-logc-github-io:-blog-2013-12-03-unicode-encodings</id>
  <published>2013-12-03T13:46:19Z</published>
  <updated>2013-12-03T13:46:19Z</updated>
  <author>
   <name>logc</name></author>
  <content type="html">
&lt;p&gt;¡Por fin he entendido cuál es la diferencia entre Unicode y UTF&amp;ndash;8! Y lo que es más importante, cómo se declaran correctamente &lt;code&gt;strings&lt;/code&gt; en Unicode en Python.&lt;/p&gt;

&lt;p&gt;Unicode es &lt;strong&gt;la tabla de equivalencias&lt;/strong&gt; entre caracteres de (casi) todos los lenguajes humanos, y un número asignado a ese caracter en concreto.&lt;/p&gt;

&lt;p&gt;UTF&amp;ndash;8 es &lt;strong&gt;la manera de comprimir&lt;/strong&gt; esos números en uno o dos bytes, en lugar de usar 4 bytes por caracter, aprovechando el hecho de que la mayoría de caracteres habituales están en los números bajos (menores de 128).&lt;/p&gt;

&lt;p&gt;Es decir, si el &amp;ldquo;encodificador&amp;rdquo; encuentra un número &amp;lt; 128, deja ese número; si encuentra uno mayor, pero menor de X (donde X es un límite que no recuerdo), usa &lt;strong&gt;dos bytes&lt;/strong&gt; para expresar este número. El &amp;ldquo;decodificador&amp;rdquo; entonces sabe que cada caracter menor de 128 está &amp;ldquo;solo&amp;rdquo;, mientras que si encuentra uno mayor, entonces debe leer también el siguiente byte para tener el número correcto con el que ir a la tabla Unicode y obtener el caracter adecuado.&lt;/p&gt;

&lt;p&gt;Se puede crear una cadena Unicode en Python usando una &lt;code&gt;u&lt;/code&gt; delante de la cadena literal, pero esto no siempre es posible, como cuando se lee de un fichero. Para convertir entre distintas codificaciones existe la función &lt;code&gt;unicode&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;La función &lt;code&gt;unicode&lt;/code&gt; &lt;strong&gt;no utiliza UTF&amp;ndash;8 por defecto&lt;/strong&gt;, sino, absurdamente, ASCII. Por eso &lt;em&gt;sólo es equivalente a poner una &lt;code&gt;u&lt;/code&gt; delante una cadena si se especifica que el &lt;code&gt;encoding&lt;/code&gt; sea &lt;code&gt;'utf-8'&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;div class="brush: python"&gt;
 &lt;pre&gt;&lt;code&gt;unicode_string = u"Años"

unicode_str = unicode(open('some.txt', 'r').read(), encoding='utf-8')&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">py2app excludes</title>
  <link rel="alternate" href="http://logc.github.io/blog/2013/12/02/py2app-excludes?utm_source=python&amp;utm_medium=Atom" />
  <id>urn:http-logc-github-io:-blog-2013-12-02-py2app-excludes</id>
  <published>2013-12-02T20:58:08Z</published>
  <updated>2013-12-02T20:58:08Z</updated>
  <author>
   <name>logc</name></author>
  <content type="html">
&lt;p&gt;Al generar una aplicación para Mac OS X con py2app, a menudo se generan ejecutables muy pesados, por ejemplo 20 MBs para una aplicación de línea de comandos (!).&lt;/p&gt;

&lt;p&gt;Uno de los problemas es que py2app tiende a incluir muchos módulos de la librería estándar de Python que en realidad no hacen falta. Se pueden excluir específicamente incluyéndolos en la opción excludes que se pasa a la función setup en el archivo setup.py usado para generar la aplicación.&lt;/p&gt;

&lt;p&gt;Con la lista siguiente, el peso baja de 22 MBs a 6 MBs. Probablemente se puede rebajar aún más.&lt;/p&gt;

&lt;div class="brush: python"&gt;
 &lt;pre&gt;&lt;code&gt;# File: setup.py

from setuptools import setup

APP = ['path/main.py']
Plist = {}
DATA_FILES = []
OPTIONS = {'argv_emulation': True,
           #'iconfile': 'Icons/ConverterIcon.icns',
           'plist': Plist,
           'excludes': [
               'aetypes',
               'ast',
               'bz2',
               'calendar',
               'codecs',
               'collections',
               'ctypes',
               'distutils',
               'doctest',
               'email',
               'encodings',
               'functools',
               'gzip',
               'inspect',
               'itertools',
               'locale',
               'logging',
               'optparse',
               'pickle',
               'platform',
               'pprint',
               'random',
               're',
               'sets',
               'shutil',
               'socket',
               'ssl',
               'subprocess',
               'tarfile',
               'tempfile',
               'threading',
               'traceback',
               'types',
               'unittest',
               'urllib',
               'urllib2',
               'urlparse',
               'weakref',
               'xml',
               'zipfile',
           ]
           }

setup(
    app=APP,
    package_dir={'': 'src'}, # you may not need this
    data_files=DATA_FILES,
    version="0.1",
    description="&amp;lt;Your description&amp;gt;",
    author="&amp;lt;Your name&amp;gt;",
    author_email="&amp;lt;Your email&amp;gt;",
    options={'py2app': OPTIONS},
    setup_requires=['py2app'],
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">Compilar Cython</title>
  <link rel="alternate" href="http://logc.github.io/blog/2013/11/19/compilar-cython?utm_source=python&amp;utm_medium=Atom" />
  <id>urn:http-logc-github-io:-blog-2013-11-19-compilar-cython</id>
  <published>2013-11-19T08:30:14Z</published>
  <updated>2013-11-19T08:30:14Z</updated>
  <author>
   <name>logc</name></author>
  <content type="html">
&lt;p&gt;Compilar ficheros de Cython es más fácil usando la función &lt;code&gt;cythonize&lt;/code&gt; dentro del setup.py de nuestro proyecto:&lt;/p&gt;

&lt;div class="brush: python"&gt;
 &lt;pre&gt;&lt;code&gt;# File: setup.py

from distutils.core import setup
from Cython.Build import cythonize

setup(
      name = "My hello app",
      ext_modules = cythonize('fibonacci.pyx'), # accepts a glob pattern
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Por ejemplo, el fichero a compilar es fibonacci.pyx, que contiene un ejemplo del tutorial de Cython:&lt;/p&gt;

&lt;div class="brush: python"&gt;
 &lt;pre&gt;&lt;code&gt;# File: fibonacci.pyx

def fib(n):
    a, b = 0, 1
    while b &amp;lt; n:
        print b,
        a, b = b, a + b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;El resultado de compilar &lt;code&gt;fibonacci.pyx&lt;/code&gt; es un fichero con código intermedio en C &lt;code&gt;fibonacci.c&lt;/code&gt; y un fichero compilado &lt;code&gt;fibonacci.so&lt;/code&gt;.&lt;/p&gt;

&lt;div class="brush: bash"&gt;
 &lt;pre&gt;&lt;code&gt;$ python setup.py build
running build
running build_ext
building 'fibonacci' extension
/usr/bin/clang ...snip... -o build/lib.macosx-10.8-x86_64-2.7/fibonacci.so&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;
 &lt;p&gt;El compilador que se utiliza es el que sea por defecto del sistema en ese momento. Aún estoy investigando cómo seleccionar un compilador en concreto, o añadir librerías y flags.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;El fichero .so puede usarse desde otros módulos de Python, o directamente desde la shell&lt;/p&gt;

&lt;div class="brush: pycon"&gt;
 &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import fibonacci
&amp;gt;&amp;gt;&amp;gt; fibonacci.fib(5)
1 1 2 3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content></entry></feed>