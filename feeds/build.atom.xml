<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
 <title type="text">logc io: Posts tagged 'build'</title>
 <link rel="self" href="http://logc.github.io/feeds/build.atom.xml" />
 <link href="http://logc.github.io/tags/build.html" />
 <id>urn:http-logc-github-io:-tags-build-html</id>
 <updated>2016-10-20T18:17:59Z</updated>
 <entry>
  <title type="text">Minimal C project structure with SCons</title>
  <link rel="alternate" href="http://logc.github.io/blog/2016/10/20/minimal-c-project-structure-with-scons?utm_source=build&amp;utm_medium=Atom" />
  <id>urn:http-logc-github-io:-blog-2016-10-20-minimal-c-project-structure-with-scons</id>
  <published>2016-10-20T18:17:59Z</published>
  <updated>2016-10-20T18:17:59Z</updated>
  <author>
   <name>logc</name></author>
  <content type="html">
&lt;p&gt;This is a possible project structure in order to have a C project using SCons as the build system. It enables you to:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;compile most files as a library, and link that to a &lt;code&gt;main&lt;/code&gt; file with application code.&lt;/li&gt;
 &lt;li&gt;separate &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;include&lt;/code&gt; directories&lt;/li&gt;
 &lt;li&gt;separate unit tests using libcheck&lt;/li&gt;
 &lt;li&gt;the unit tests link to the library&lt;/li&gt;
 &lt;li&gt;Macports-installed libraries&lt;/li&gt;&lt;/ul&gt;
&lt;!-- more--&gt;

&lt;p&gt;Layout your code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── include
│   └── core
│       └── mylib.h
├── sconstruct
├── src
│   ├── core
│   │   └── mylib.c
│   └── main.c
└── tests
    ├── core
    │   ├── test_mylib.c
    │   ├── test_mylib.h
    │   └── tests.h
    └── main.c&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;mylib&lt;/code&gt; should have a more descriptive name for your project.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sconstruct&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;env = Environment(CPPPATH=['include', '/opt/local/include'])
env.Library(target='mylib', source=Glob('src/core/*.c'))
env.Program(target='mylib', source=Glob('src/*.c'),
            LIBS=['mylib'], LIBPATH=['.'])
env.Program(target='test_mylib', source=Glob('tests/*.c') + Glob('tests/**/*.c'),
            LIBS=['mylib', 'check'], LIBPATH=['.', '/opt/local/lib/'])&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="implementation"&gt;Implementation&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;src/core/mylib.c&lt;/code&gt; (and all other files in subdirectories of &lt;code&gt;src/&lt;/code&gt;) holds the core logic without user interactions (pure functions, if you wish :) ). It can look like this:&lt;/p&gt;

&lt;div class="brush: c"&gt;
 &lt;pre&gt;&lt;code&gt;int whatever() {
    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;src/main.c&lt;/code&gt; uses all other files in order to do something useful for a user. For instance:&lt;/p&gt;

&lt;div class="brush: c"&gt;
 &lt;pre&gt;&lt;code&gt;#include "core/mylib.h"

int main() {
    return whatever();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;main.c&lt;/code&gt; and &lt;code&gt;core/mylib.c&lt;/code&gt; see each other via the header files in the include directory, where &lt;code&gt;core/mylib.h&lt;/code&gt; holds:&lt;/p&gt;

&lt;div class="brush: c"&gt;
 &lt;pre&gt;&lt;code&gt;int whatever();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="tests"&gt;Tests&lt;/h2&gt;

&lt;p&gt;Tests have the same subdirectory structure as the source subtree (a &lt;code&gt;core&lt;/code&gt; directory to hold tests for &lt;code&gt;core&lt;/code&gt; implementation files), but headers are included in the same subtree, because tests are not expected to need to publish their API to end-users, only their results.&lt;/p&gt;

&lt;p&gt;A typical test file, e.g. &lt;code&gt;tests/core/test_mylib.c&lt;/code&gt;, should define tests, and then define a function that puts them together into a test suite. This is the function that we will want to expose via a header file:&lt;/p&gt;

&lt;div class="brush: c"&gt;
 &lt;pre&gt;&lt;code&gt;#include &amp;lt;check.h&amp;gt;

START_TEST(test_fails)
{
    ck_assert_int_eq(1, 2);
}
END_TEST

Suite * core_suite(void)
{
    Suite *s;
    TCase *tc_core;

    s = suite_create("Core/mylib");

    /* Core test case */
    tc_core = tcase_create("Core");

    tcase_add_test(tc_core, test_fails);
    suite_add_tcase(s, tc_core);

    return s;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In this example, we create a header file for each test file in a directory, and then an aggregated header file called &lt;code&gt;tests.h&lt;/code&gt; which includes all other header files in the same directory:&lt;/p&gt;

&lt;div class="brush: c"&gt;
 &lt;pre&gt;&lt;code&gt;// test_mylib.h
Suite * core_suite(void);

// tests.h
#include "test_mylib.h"&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Finally, the test runner executable is defined in the tests/main.c file. It includes all tests headers, uses the exported test suite creating functions to create all test suites, and runs them.&lt;/p&gt;

&lt;div class="brush: c"&gt;
 &lt;pre&gt;&lt;code&gt;// tests/main.c
#include &amp;lt;stdlib.h&amp;gt;

#include &amp;lt;check.h&amp;gt;

#include "core/tests.h"

int main(void)
{
    int number_failed;
    Suite *s;
    SRunner *sr;

    s = core_suite();
    sr = srunner_create(s);

    srunner_run_all(sr, CK_NORMAL);
    number_failed = srunner_ntests_failed(sr);
    srunner_free(sr);
    return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;

&lt;p&gt;Build your project with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scons&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will find three products:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;a static library called &lt;code&gt;libmylib&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;an executable called &lt;code&gt;mylib&lt;/code&gt;, which links to that library&lt;/li&gt;
 &lt;li&gt;a test executable called &lt;code&gt;test_mylib&lt;/code&gt;, also linked to that library&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;You can run all tests with &lt;code&gt;./test_mylib&lt;/code&gt;, and execute the program with &lt;code&gt;./mylib&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can clean all object files and the products with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scons --clean&lt;/code&gt;&lt;/pre&gt;</content></entry></feed>